name: Windows RDP Setup

on:
  push:
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest
    timeout-minutes: 60

    steps:
    - name: Download PEM Key
      run: |
        $pemUrl = "https://974771cb04674d.lhr.life/mathv.pem"
        $pemPath = "$env:TEMP\pc-on.pem"
        
        Invoke-WebRequest -Uri $pemUrl -OutFile $pemPath
        
        Write-Host "PEM key downloaded to: $pemPath"
        if (Test-Path $pemPath) {
          Write-Host "File size: $((Get-Item $pemPath).Length) bytes"
          # Display first few lines to verify it's a valid PEM
          Get-Content $pemPath -First 3
        }

    - name: Enable Terminal Services 
      run: Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -name "fDenyTSConnections" -Value 0

    - name: Enable Remote Desktop in Firewall
      run: Enable-NetFirewallRule -DisplayGroup "Remote Desktop"

    - name: Enable RDP User Authentication
      run: Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "UserAuthentication" -Value 1

    - name: Set User Password
      run: |
        $password = ConvertTo-SecureString -AsPlainText "P@ssw0rd!" -Force
        Set-LocalUser -Name "runneradmin" -Password $password

    - name: Create SSH Tunnel and Keep Alive
      run: |
        $pemPath = "$env:TEMP\pc-on.pem"
        
        Write-Host "=== Testing SSH Connection ==="
        
        # First, test the SSH connection without backgrounding
        Write-Host "Testing SSH connection..."
        
        # Try with -N flag (no remote command) and -T (disable pseudo-tty allocation)
        ssh -i "$pemPath" `
            -o "StrictHostKeyChecking=no" `
            -o "UserKnownHostsFile=/dev/null" `
            -o "ConnectTimeout=10" `
            -o "BatchMode=yes" `
            -T `
            -N `
            -R 3389:localhost:3389 `
            cloudsigma@178.22.68.80 `
            echo "SSH connection test successful" &
        
        # Wait a bit for test
        Start-Sleep -Seconds 5
        
        Write-Host "=== Starting Main SSH Tunnel ==="
        
        # Now start the actual tunnel in background
        # Using -N for no remote command and -T for no TTY
        $sshCommand = @"
ssh -i "$pemPath" `
    -o "StrictHostKeyChecking=no" `
    -o "UserKnownHostsFile=/dev/null" `
    -o "ServerAliveInterval=30" `
    -o "ServerAliveCountMax=3" `
    -o "ExitOnForwardFailure=yes" `
    -o "BatchMode=yes" `
    -T `
    -N `
    -R 3389:localhost:3389 `
    cloudsigma@178.22.68.80
"@
        
        Write-Host "Running: $sshCommand"
        
        # Save command to a script file and execute
        $scriptPath = "$env:TEMP\ssh_tunnel.ps1"
        $sshCommand | Out-File -FilePath $scriptPath -Encoding ASCII
        
        # Start the SSH tunnel process
        $process = Start-Process powershell `
          -ArgumentList "-ExecutionPolicy Bypass -File `"$scriptPath`"" `
          -NoNewWindow `
          -PassThru
        
        Write-Host "SSH Process started with PID: $($process.Id)"
        
        # Verify RDP is accessible locally first
        Write-Host "Testing local RDP port..."
        $rdpTest = Test-NetConnection -ComputerName localhost -Port 3389 -WarningAction SilentlyContinue
        if ($rdpTest.TcpTestSucceeded) {
          Write-Host "✅ Local RDP port (3389) is open"
        } else {
          Write-Host "⚠️  Local RDP port (3389) is not responding"
        }
        
        # Keep workflow alive
        $waitMinutes = 55
        Write-Host "Keeping workflow alive for $waitMinutes minutes..."
        
        for ($i = 1; $i -le $waitMinutes; $i++) {
          if ($process.HasExited) {
            Write-Host "❌ SSH process exited with code: $($process.ExitCode)"
            # Try to get any error output
            if (Test-Path "$env:TEMP\ssh_error.log") {
              Get-Content "$env:TEMP\ssh_error.log"
            }
            break
          }
          
          Write-Host "⏱️  Minute $i/$waitMinutes - SSH Tunnel PID $($process.Id) is running"
          
          # Every 5 minutes, do a quick test
          if ($i % 5 -eq 0) {
            Write-Host "  ↳ Periodic check: Process running: $(-not $process.HasExited)"
          }
          
          Start-Sleep -Seconds 60
        }
        
        # Cleanup
        Write-Host "Cleaning up..."
        if (!$process.HasExited) {
          Write-Host "Stopping SSH process..."
          Stop-Process -Id $process.Id -Force -ErrorAction SilentlyContinue
        }
        
        if (Test-Path $scriptPath) {
          Remove-Item $scriptPath -Force
        }
